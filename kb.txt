2013.6-2015.11 12 + 5.5+2.5 = 20
2016.6-2019.4  12 + 3       = 15
2019.4-2020.7  21.6 + 1.4   = 23
2019.4-2020.7  36   +  14   = 50

1 6.18    相互保2interview，1、HashMap线程不安全，为什么线程不安全，如何修改代码线程安全。
          解：HashMap线程不安全的后果主要有造成死循环、数据丢失、数据覆盖。jdk1.7线程不安全主要由扩容函数引起的。jdk1.8由put函数并发的时候引起数据覆盖。如果两个线程同时插入，插入同一个bucket中的链表。
                            2、HashMap，equal和hashcode。
                            3、volitale：比synchronize轻量级的同步机制，多线程编程里的可见性，volitale修饰的词主要不会写到线程CPU缓存中，而是直接写入内存。一个线程修改了某个值，另一个线程立即可见，而非volitale变量则在线程中读写时，变量会被拷贝到CPU缓存中。
							             原理就是加上了lock指令，告诉编译器禁止优化。以主内存的值为主，cpu自己cache里的值无效。
                            4、pv uv，日志按天分log文件，日志格式为【ip，url，客户端类型】，linux用什么命令来统计pv，uv： 方法1：cat xx | sort | uniq |wc  或者awk '!x[$0]++' filename
                            5、AOP：
                            6、说一下shuffle：
                            7、Hbase在什么场景下使用
                            8、Hive数据倾斜      ：数据倾斜是进行大数据计算时常见的问题。主要分为map端倾斜和reduce端倾斜，map端倾斜主要是因为输入文件大小不均匀导致，reduce端主要是partition不均匀导致。                       
2 6.19 酱油                     
3 6.20 酱油
4 6.21 酱油    
5 6.22 酱油
6 6.23 酱油 
7 6.24 酱油 
8 6.25 酱油 
9 6.26 酱油 
10 6.27酱油 
11 6.28酱油 
12 6.29酱油 
13 6.30酱油 
14 7.01酱油 
15 7.02酱油 
16 7.03酱油
17 7.04酱油
18 7.05酱油
19 7.06酱油
20 7.07酱油
21 7.08酱油
22 7.09酱油
23 7.10酱油
24 7.11酱油
25 7.12酱油
26 7.13酱油
27 7.14酱油
28 7.15酱油
29 7.16酱油
30 7.17酱油
31 7.18酱油
32 7.19酱油
33 7.20酱油
34 7.21酱油
35 7.22干！
36 7.23干！
37 7.24干！
38 7.25干！
39 7.26 https://baijiahao.baidu.com/s?id=1667846581124648589&wfr=spider&for=pc
40 7.27
41 7.28
42 7.29
43 7.30
44 7.31
45 8.01
46 8.02
47 8.03
48 8.04
49 8.05
50 8.06
51 8.07
52 8.08
53 8.09
54 8.10
55 8.11
56 8.12
57 8.13
58 8.14
59 8.15
60 8.16
61 8.17
62 8.18
63 8.19
64 8.20
65 8.21
66 8.22
67 8.23
68 8.24
69 8.25
70 8.26
71 8.27
72 8.28
73 8.29
74 8.30
75 8.31


















just刚刚开始，拒绝舒适区，se、game!
1、语言：Java技术，基础，Spring框架，微服务，JDK，SQL
2、工程化：推荐系统，友盟。
3、工作专心致志：8h
4、银行or福报随意



************
【维新】
************
2019-7-2----------2019-9-10
1、神经网络：DNN全连接，CNN卷积神经网络（图像识别），RNN循环神经网络（语音识别），NLP自然语言处理
2、算法：    数据挖掘算法及其应用场景：随机森林，决策树，knn近邻算法，svm支持向量机，k-means聚类算法，cart分类与回归树，naive Bayes朴素贝叶斯，逻辑回归。
3、python基础：keras熟练使用，TensorFlow，pandas，numpy，plot。
4、大数据：spark core， spark sql，spark ml，hadoop，sqoop，flume，zookeeper，kafka 。
5、Java基础：spring boot ，NIO等等。

*********
【JAVA】
*********



【1】post与get的区别
post更安全，把数据装到request body中，但耗时更久。
get不安全，url中直接包含了用户等信息，但效率更高，与服务端只交互一次。而post需要来回交互两次，第一次发送post头，然后第二次才发送内容。

【2】cookie与session的区别
cookie保存在客户端，session是服务端的概念。
cookie相当于服务端给客户端的一个通行证，然后客户端保存在自己的浏览器中，每次访问服务器时，会连同cookie一起提交给服务器。
因为http是无状态协议，因此一次连接的数据传输完成后，连接就断开。下次再连接的时候，服务器无法判断你是哪个用户。
因此服务器就需要一种机制来保存用户的信息，这就是session。第一次创建session时，就会在cookie里记录一个session id，发给客户端，
以后客户端每次发送请求的时候就会把sid发给服务器，服务器就能找到对应的session。
session第二个主要作用是，服务器一般把Session放在内存中，做session缓存，减少用户与数据库的频繁交互，例如电商购物车。 
-------------------------------------------------------------------------------------------------------------------
【3】转发与重定向
重定向：浏览器行为，浏览器发送两次请求，得到两次响应，response.sendRedirect
转发：服务器行为，发出一次请求，得到一次回应，地址栏不会变化。request.getRequestDispatcher
-------------------------------------------------------------------------------------------------------------------
【方法区与永久代与元数据空间MetaSpace】
方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。
在java1.7开始移除老年代，1.8彻底移除了老年代，取而代之的是MetaSpace。主要区别是MetaSpace放在本地内存，就不会出现永久代OOM内存溢出问题。

方法区存放什么东西：类信息，class文件，static变量与方法，final常量
-------------------------------------------------------------------------------------------------------------------
【设计模式】
spring IOC，控制反转：使用依赖注入
http://www.mamicode.com/info-detail-2691212.html
工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。

代理设计模式 : Spring AOP 功能的实现。

单例设计模式 : Spring 中的 Bean 默认都是单例的。

模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

装饰器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。

适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

JDBC 桥接模式。
-------------------------------------------------------------------------------------------------------------------
【IOC AOP】
IoC（反向控制），降低了业务逻辑中各个类的相互依赖。
以前需要自己new一个类，现在通过ioc spring帮我们创建和管理，我们直接使用就行了。如果后续代码升级需要改动，只需要改配置文件，降低耦合，提高重用性。
假如类A因为需要功能F而调用类B，在通常的情况下类A需要引用类B，因而类A就依赖于类B了，也就是说当类B不存在的时候类A就无法使用了。
使用了IoC，类A调用的仅仅是实现了功能F的接口的某个类，这个类可能是类B，也可能是另一个类C，由spring的配置文件来决定。这样，类A就不再依赖于类B了，耦合度降低，重用性提高了。

-------------------------------------------------------------------------------------------------------------------
【单例模式】
单例的作用：确保一个类只有一个实例，在整个jvm中保持唯一性，唯一的一些资源，比如线程池可以用单例。优点是唯一性，并且可以省去对象反复的创建与销毁的过程，节省资源。
懒汉式：只有在调用的时候才初始化，这样比较节省资源，但是调用的时候每次都要判断是否已经创建过单例了。
饿汉式：程序一启动就创建实例。这样会比较占资源，但是调用的时候不需要判断是否创建过单例。
-------------------------------------------------------------------------------------------------------------------
【工厂模式】
工厂模式的作用：一是方便维护。如果一份代码里有很多new操作，要进行修改的时候，代码的每一个地方都要修改。而把new操作封装在工厂里，就只要改一个地方了。
                二是符合低耦合的一个编程思想，比如有两份代码A和B，B想调用A的类，就需要new一个A，这样就会耦合在一起。但是如果使用工厂的话，对调用工厂并传参就可以得到具体的对象。
-------------------------------------------------------------------------------------------------------------------
【代理模式】
比如我不想或者不能直接调用某个类，就给他封装一层代理，我直接调用这个代理类来实现响应的功能。好处是他是一个中介，屏蔽了委托类的细节。
另外如果想增加点新功能，但不想直接修改委托类，可以在代理类上实现。
-------------------------------------------------------------------------------------------------------------------
【前后端分离】
前后端不分离的情况就是，客户端发一个请求，服务端准备好完整的页面和数据发给客户端。每次页面和数据都会发过来，传输的内容很多。
前后端分离的情况就是服务端只提供数据，一般的做法就是前端使用ajax，后端提供restful的接口，数据以json格式传输。
-------------------------------------------------------------------------------------------------------------------
【动静分离】
所谓的动静分离就是指图片，css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理
好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。 
-------------------------------------------------------------------------------------------------------------------
【Springboot】
Springboot省去了SpringMVC繁琐的配置，并且内置了tomcat，相当于一个简化开发的开发环境。
-------------------------------------------------------------------------------------------------------------------
【SpringMVC】

-------------------------------------------------------------------------------------------------------------------
【RPC】
RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从节点与节点直接请求服务，就像是在本地调用接口服务一样。
RPC 是一种技术思想，并不是一种规范，实现它的框架比如dubbo，springcloud，netty
在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。比如springcloud是http。
tcp协议的rpc更能减少网络开销，实现更大的吞吐量和并发数。但开发难度较大。
http协议虽然网络开销更大，但是处于上层，进行二次开发非常方便。
-------------------------------------------------------------------------------------------------------------------
【Netty】
Netty是一款基于NIO开发的网络通信框架，对比于BIO，他的并发性能得到了很大提高。
说白了就是有一个select轮询实现多路复用 也叫事件驱动。linux里也有多路复用，select和epoll轮询
-------------------------------------------------------------------------------------------------------------------
【线程池参数】
核心线程数
最大并发线程数
普通线程的空闲超时时间。
缓存队列，超过常驻的线程数的线程会进入到缓存队列，队列满了就会创建新的线程直到max最大线程数。
拒绝策略，队列满了之后，线程池到了max，那么新的任务是否丢弃还是等待。

-------------------------------------------------------------------------------------------------------------------
【同步、异步、阻塞、非阻塞】
我们写一个程序，他的执行和调用过程要分为用户空间和内核空间。
阻塞指的就是用户空间发出的一个操作，要等待内核空间返回结果才执行下一步操作，内核没有返回用户空间就一直阻塞着。
非阻塞的方式就是用户空间发出的一个操作，内核立即给出一个状态值，用户空间不用等待内核空间的IO操作完成，就可以执行下一步动作。

同步异步说的是用户空间与内核空间的调用方式。
同步就是用户空间主动发起IO请求，内核空间接收请求。
异步是内核空间主动发起请求，用户空间接收。
-------------------------------------------------------------------------------------------------------------------
【bio，nio，aio】
bio是阻塞同步io，nio是非阻塞同步io，也就是多路复用io。

网络编程中，bio一个连接对应一个线程，
IO多路复用模型的基本原理就是select/epoll系统调用，单个线程不断的轮询select/epoll系统调用所负责的成百上千的socket连接，
当某个或者某些socket网络连接有数据到达了，就返回这些可以读写的连接。
系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。
-------------------------------------------------------------------------------------------------------------------
【epoll与select区别】
select轮询效率低，主要表现在select轮询到有socket数据时，还需要遍历一次socket列表来确定具体那一个socket收到了数据。
因为每次都要遍历，所以select有限制最多监听socket1024.
epoll就没有这个限制。epoll不仅维护了socket监听列表，还维护了一个socket就绪列表。这样一旦有socket收到数据，直接将socket
写入到就绪列表中，不需要遍历监听列表了。
-------------------------------------------------------------------------------------------------------------------
【序列化与反序列化】
网络中传输是以二进制流的形式传输的，序列化就是把java对象转换成字节序，方便在网络中传输。
反序列化就是把收到的字节序转换为java对象。
-------------------------------------------------------------------------------------------------------------------
【HashMap】
hashmap相当于数组和链表的一个结合方案。
数组插入和删除数据涉及移动数据，但它空间占用少。
链表新增删除数据很方便，但空间占用多。
数组和链表的平均复杂度都为o（n）
hashmap主干使用数组，通过key和映射关系直接找到数组的位置，时间复杂度为0(1)
但是映射关系可能会导致不同的key找到同一个位置，这就是hash冲突，为了解决这个问题，引入了链表，如果遇到冲突，
就以链表形式加在它位置的后面。
-------------------------------------------------------------------------------------------------------------------
【redis】
基于k-v的内存数据库，一般在业务系统中数据量较大的交互时，做缓存使用，加快响应速度，提升用户体验。
-------------------------------------------------------------------------------------------------------------------
【redis缓存击穿问题】
缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库异常。
解决方案：数据库访问排队上锁，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。
-------------------------------------------------------------------------------------------------------------------
【redis雪崩】
缓存在同一时间内大量k-v过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。
解决方案：
方案1、也是像解决缓存穿透一样加锁排队，实现同上;
方案2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;

-------------------------------------------------------------------------------------------------------------------
【大数据】
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【RDD】
弹性分布式数据集。逻辑上数据是各个节点分片存储的，但是在操作上可以看成一个整体，针对RDD进行编程操作。
-------------------------------------------------------------------------------------------------------------------
【RDD算子】
Transform类（生成新的RDD，transform并不会执行计算）：map，flatmap，groupbykey，reducebykey，join，union，filter等。
Action类（生成结果，只有在遇到action的时候才开始计算）：count，collect，reduce，lookup，save。
-------------------------------------------------------------------------------------------------------------------
【RDD宽窄依赖】
所谓窄依赖是指，RDD的各个节点上的分片数据在各自节点上操作就可以了。父子RDD的分区是一一对应的。
而宽依赖是指，父子RDD是多对多的关系，也就是说要得到下游RDD中的某个分区数据，依赖于上游多个RDD分区数据。
-------------------------------------------------------------------------------------------------------------------
【pipline】
在管道中，数据一直在运转，管道没有空闲。
在窄依赖中，数据是按照pipline模式进行的，数据不落地。
比如一个RDD分为2个partition，在窄依赖中进行filter，map操作。那么数据就有两个Task，进行pipline处理。任务数根据窄依赖中
最后一个RDD的分区数来确定。
-------------------------------------------------------------------------------------------------------------------
【DAG有向无环图】
图论中的一个概念，有向图中的一个节点按方向无法回答本节点。
DAG有向无环图主要是在一个任务流过程中切分Stage的，RDD窄依赖的操作可以看做一个整体一起执行，而遇到窄依赖则划分为另一个
stage。中间结果不落盘。
-------------------------------------------------------------------------------------------------------------------
【SparkSchedule】
Spark的任务调度就是如何组织任务去处理RDD中每个分区的数据，根据RDD的依赖关系构建DAG，基于DAG划分Stage，将每个Stage中的
任务发到指定节点运行。
-------------------------------------------------------------------------------------------------------------------
【Driver】
Driver作为Spark应用程序的总控，负责分发任务以及监控任务运行状态
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【人工智能应用】
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【什么是机器学习】
机器学习最通俗的解释就是让机器学会决策。再稍微具体点，就是通过喂给机器一定量的历史数据，得到一个可以决策的模型，当
有新数据过来的时候，通过模型可以给出预测。
从预测值的类型上看，连续变量预测的定量输出称为回归；离散变量预测的定性输出称为分类。例如：预测明天多少度，是一个回
归任务；预测明天阴、晴、雨，就是一个分类任务。
-------------------------------------------------------------------------------------------------------------------
【有哪些应用】
1、防垃圾邮件系统
2、推荐系统
3、车牌号识别
4、人脸识别
5、语音识别
6、图像识别
7、
-------------------------------------------------------------------------------------------------------------------
【智能投顾】

-------------------------------------------------------------------------------------------------------------------
【防欺诈模型】
构建知识图谱（存放图数据库Neo4j），挖掘关系网络中隐藏的欺诈风险。
从算法的角度来讲，有两种不同的场景：一种是基于规则的；另一种是基于概率的。

基于规则：1、不一致性验证，通过规则找到矛盾点，比如张三李四在不同公司上班，但是拥有相同的电话号码。
          2、基于规则提取特征，申请人二度人脉关系中有多少进了黑名单。
数据量多的时候：
基于概率：比如社区挖掘（），标签传播（优秀的人有的特质，朋友也可能会有），
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【人工智能应用】
-------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------
【监督式学习】
 在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，例如，防垃圾邮件系统，识别手写数字识等。
-------------------------------------------------------------------------------------------------------------------
【线性回归】
解决回归问题，例如通过目前已有的数据来画一条线，然后希望新的数据也能尽可能落在这条线上。
通过损失函数计算误差，并且利用梯度下降法，逐步最小化损失函数。
-------------------------------------------------------------------------------------------------------------------
【最小二乘】
线性回归的一种计算方法，每个点到直线上的垂直距离，加起来值最小，那么这条线就是拟合最好的线。
-------------------------------------------------------------------------------------------------------------------
【逻辑回归】
虽然带有回归字样，但是属于分类算法，多用于二分类，结果取值[0-1],以0.5为分界，大于0.5的为一类，小于0.5为一类，
逻辑回归公式就是sigmoid。
-------------------------------------------------------------------------------------------------------------------
【Knn近邻算法】
给一个新的数据时，离它最近的 k 个点中，哪个类别多，这个新数据就属于哪一类。
选k个邻居，然后统计哪个类别的邻居最多，那么我就属于哪一类。关键点：选择合适的K值。
例子：要区分两个类别A和B，设置k=3，那么取三个最近的点，A类有2个，B类有1个，那么这个点就属于A类。
-------------------------------------------------------------------------------------------------------------------
【K-Means均值算法】聚类
先将一组数据分为3（K类）类。
第一步在这组数据中随机选3个点作为3个原点，然后计算每个点到这3个原点的距离。离哪个原点最近，就属于哪个类别。
第二步再计算着三个类的平均值作为新的原点。然后再计算所有点分别离这3个原点的距离，如果一个点距离某个原点最近，那么属于那一类。
然后反复迭代，不停的计算新原点，不停的重新聚类，直到结果相对收敛。
-------------------------------------------------------------------------------------------------------------------
【决策树】
决策树通常有三个步骤：特征选择、决策树的生成、决策树的修剪。
一些概念：信息增益  = 经验熵 - 条件熵。
根据信息增益来可以确定谁是最优特征，最优特征为根。
由于决策树生成后，对于训练样本来说是过拟合的，因此通过损失函数来进行修剪，提高决策树的泛化能力。
-------------------------------------------------------------------------------------------------------------------
【随机森林】
集成学习（ensemble）思想是为了解决单个模局限性缺陷，从而整合起更多的模型，取长补短，避免局限性。
森林是指有多颗决策树，而随机是指每颗决策树的特征条件是随机选择的，是不一样的。
假设样本总数为M，特征个数为F，
选择样本个数N<M,
选择特征a<F，
选择决策树颗数为K。
创建时，每个决策树随机选定数目为a的条件，随即选定数目为N的样本。
创建完成后，将测试样本带入森林，每颗决策树会给出决策，然后汇总并做最终决策。并与实际结果做比较。
调参：理论上来说，随机森林中树的数目越多，模型的效果就越好。但这种效果是递减的，而且消耗计算资源，
因此需要取一个合适的值。
-------------------------------------------------------------------------------------------------------------------
【朴素贝叶斯】
有一个贝叶斯公式。主要描述的是后验概率，即在已知某种条件发生后，事件的发生概率是多少？
P(A|B) = P(A)P(B|A)/P(B)
通常用于NLP自然语言处理中。比如垃圾邮件分类等。
假设样本x（特征f1，f2，f3）需要分类。
类别y1，y2.
求x属于y1还是y2。
P（y1|x） = P（y1）P（x|y1）/P（x）
P（y2|x） = P（y2）P（x|y2）/P（x）
分母一样可以不计算。
并且朴素的意思就是假设没有个特征都是相互独立的。那么：
P（y1|x） = P（y1）P（f1|y1）P（f2|y1）P（f3|y1）
P（y2|x） = P（y2）P（f1|y2）P（f2|y2）P（f3|y2）
而P（y1），P（y2），P（f1|y1），P（f1|y2）等这些都可以在统计资料里得到统计概率。计算谁大，就属于那一类了。
-------------------------------------------------------------------------------------------------------------------
【SVM支持向量机】
支持向量机（support vector machines）是一种二分类模型，它的目的是寻找一个超平面来对样本进行分割，而对于分割来说，有
无数种分法，。那么支持向量机的分割原则是间隔最大化，就是选择两个样本边界的正中间作为划分界限。
这样对于样本的扰动容忍性最好。如果划分的不好，在边界附近的新样本很容易错误的归类。
-------------------------------------------------------------------------------------------------------------------
【协同过滤collaborative filtering CF】
推荐系统常用，
基于用户的协同过滤。用户A和B很像，将A喜欢的东西推荐给B。
基于物品的协同过滤。物品A和物品B很像。那么我就将B推荐给喜欢A的人。
如何衡量这个相似呢，主要有几种距离评价算法。欧氏距离，曼哈顿距离。
-------------------------------------------------------------------------------------------------------------------


TCPIP，4层
应用程序--TCP层--IP层，网络接口层。
三次握手，四次挥手。
比如我浏览网页，经过web应用到网卡把我的请求发送出去，应用层http协议加一个http头，
到tcp层，加一个tcp协议的头（包含目的端口，源端口），经过IP层加一个IP头（目的IP地址，源IP地址），
在经过接口层，加上帧头mac地址，帧尾（校验和），封装成帧在网线等介质中传输。

滑动窗口：流量控制技术，



【如何制作linux发行版】
1、做一些准备工作，比如选择选择合适的linux宿主机。准备基础工具集，比如gcc，make汇编等工具链源码包。然后linux系统需要的最小软件包集合minimal，bash，网络管理工具等等，还有选好内核。
2、构建都是在宿主机上进行的，创建独立的分区和文件系统，通过宿主机编译gcc，make汇编等工具链。
3、使用chroot，创建根目录下的文件夹，准备好内核，并根据之前构建的工具集合把minimal中的包都编译一遍，放入指定的目录，比如很多编译好的工具需要放到bin目录，或者sbin目录。
4、接下来做配置工作，包括网络配置、时钟设置，本地化设置，/etc下面的很多配置，systemd配置。
5、最后做启动的配置，/etc/fstab挂载点，grub2启动引导。
6、基本的系统起来后，你可以做一些个性化的工作，比如你更关注虚拟化，可以集成相关虚拟化的软件，你喜欢桌面，可以集成桌面相关的包，比如x-server，KDE，mate，gnome

Hang机解决：首先判断是真死机还是假死机。比如服务器提供的服务不可用了，无法访问。
直接登录服务器，如果能登录，进去查看资源使用情况，比如top的cpu占用，内存使用，磁盘使用。
查看网络以及磁盘io的情况。是不是请求太多，io阻塞了。Top 查看cpu有90以上wait，很可能就是io阻塞造成的。
使用一些工具比如iostat查看io使用情况，查看是哪个进程占用较高，查看是哪些文件的读写较高，一步一步找到问题。

-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【云计算】
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【kvm与xen区别】
1、kvm全虚拟化，xen半虚拟化
kvm是集成到内核中的一个动态模块，kvm.ko。需要硬件支持，比如intel和amd的cpu虚拟化支持。
xen的话，没有被集成到内核中，因此需要改造我们的内核，xen是可以直接运行在我们的硬件之上的。然后在xen的hypervisor之上运行我们的domain-0超级管理员。管理我们的虚拟机domain1-N。
而kvm全虚拟化，是把虚拟机完全的当成一个主机来运行的，运行在支持kvm内核的os之上。

-------------------------------------------------------------------------------------------------------------------
【qemu】
qemu是一套虚拟化解决方案，他可以虚拟出不同架构上的cpu，kvm只是内核模块，在核外的管理工具就是使用的改造后的qemu，

-------------------------------------------------------------------------------------------------------------------
【libvirt】

Hi，很久不见了，最近还好吗？想了很久开口对白，没想到还是这么落入俗套哈哈。每次想和你说点什么但总夹杂着悲伤的感情，写得伤感听的也压抑。那我就说点开心的事情吧，
希望大家都能好起来！我说我爱你但是却没有给你做任何事情，我说我

-------------------------------------------------------------------------------------------------------------------
【KVM-Qemu-Libvirt三者之间的关系】
在所谓的kvm技术中，应用到的其实有2个东西：qemu+kvm
kvm负责cpu虚拟化+内存虚拟化，但kvm不能模拟其他设备；
qemu是模拟IO设备（网卡，磁盘），kvm加上qemu之后就能实现真正意义上服务器虚拟化。
因为用到了上面两个东西，所以一般都称之为qemu-kvm。
libvirt则是调用kvm虚拟化技术的接口用于管理的，用libvirt管理方便，直接用qemu-kvm的接口太繁琐。

-------------------------------------------------------------------------------------------------------------------

【OpenStack】
OpenStack 控制节点，计算节点nova，网络节点neutron，存储节点swift，


【io虚拟化】
io三种模式：全虚拟化，半虚拟化（virtio），直通穿透（硬件支持）
全虚拟化：kvm有一个io拦截模块，截取虚拟机中的io请求，然后发给qemu，由qemu负责与硬件进行交互。
半虚拟化：


【安全加固Selinux】
有三个账户，root管理员：管理软件安装启动，比如创建普通账号，安装软件，启动某些服务。
            安全管理员：负责安全属性的设置，
            审计管理员：查看，审查所有的日志信息
好处就是安全性非常高，三个账户相互制约。但使用起来也是非常的头疼，比如我要安装一个软件，软件包需要安全账户进行审核放行，root管理员才能安装，我要启动服务，也需要安全管理员开放端口，出了问题查看日志又需要审计账户，尤其是在上面开发，更困难。
原理：我们访问者访问任何linux资源，这些访问请求都会经过selinux的服务。然后selinux维护了一个策略数据库，谁能访问哪些资源都写在策略里，符合就放行，不符合就拒绝并记录审计日志。


【负载均衡】
负载均衡看主要是工作在第几层
二层负载均衡：对外提供虚拟IP，集群IP都相同，mac不同，负载均衡服务器拿到请求后，改写mac发给集群不同机器。
三层负载均衡：对外提供虚拟IP，集群中ip不同。负载均衡器拿到请求后，根据负载均衡算法把请求发给集群中不同机器。
四层负载均衡：工作在传输层，改写目标IP地址，端口，将请求发给集群中应用服务器。
七层负载均衡：工作在应用层，比如可以根据具体的应用协议，比如http协议，将某些内容指定发给集群不同机器。它需要关注数据内容是啥，依据内容进行转发。

总的来说，一般是lvs做4层负载；nginx做7层负载；haproxy比较灵活，4层和7层负载均衡都能做

算法：轮询，随机，加权，最小压力等等。

【哈希Hash Table】
通常的数据结构有链表，和数组。HashMap就是数组和链表的结合。



【进程间的通信方式】


容器 = cgroup + namespace + rootfs + 容器引擎
cgroup做资源管理，namespace做资源隔离。
一、cgroup
cgroup子系统 	作用
devices 	设备权限控制
cpuset 	        分配指定的CPU和内存节点
CPU 	        控制CPU使用率
cpuacct 	统计CPU使用情况
memory 	        限制内存的使用上限
freezer 	暂停Cgroup 中的进程
net_cls 	配合流控限制网络带宽
net_prio 	设置进程的网络流量优先级
perf_event 	允许 Perf 工具基于 Cgroup 分组做性能检测
huge_tlb 	限制 HugeTLB 的使用
在 Cgroup 出现之前，只能对一个进程做资源限制，如 ulimit 限制一个进程的打开文件上限、栈大小。而 Cgroup 可以对进程进行任意分组，如何分组由用户自定义。

二、 Namespace
Namespace 是将内核的全局资源做封装，使得每个namespace 都有一份独立的资源，因此不同的进程在各自的namespace内对同一种资源的使用互不干扰。
Namespace 	作用
IPC 	        隔离 System V IPC 和 POSIX 消息队列
Network 	隔离网络资源
Mount 	        隔离文件系统挂载点
PID 	        隔离进程ID
UTS 	        隔离主机名和域名
User 	        隔离用户和用户组



【负责工作】
1、负责公司服务器产品的定制开发与维护升级工作，以及基础的服务器方案设计部署维护，比如高可用，负载均衡方案、存储方案等等，系统会有多个版本，基于物理平台的x86，arm64，。

2、负责服务器产品及系统等新技术的预研，例如安全加固、软件升级、备份还原、内核热补丁、服务器产品License设计等等。

3、负责华为云平台FusionCompute/华为云桌面FussionAccess与麒麟操作系统及麒麟存储产品的适配工作。在我们的系统上部署云平台，在云虚拟机上适配我们的麒麟系统等等。
虚机安装出错，安装出来后vnc显示异常。

4、开发工作：1、麒麟安全系统中的数据迁移工具，安全系统中的某几个分区满了，需要增加物理存储并扩容。在安全系统中，每一步操作都会涉及到权限问题，需要写安全策略以及提权等相应操作来应对，所以会非常的复杂。
             2、麒麟服务器产品的License的生成器，主要是使用RSA公钥私钥加解密，公司License生成器使用公钥进行加密，服务器产品内嵌的私钥进行解密这样一套系统。C/C++
             3、基于开源高可用产品pacemaker+Corosync的改造定制。C/C++
             4、麒麟软件升级工具的编写：已经卖出去的服务器OS，但是客户是不允许联网的，但OS里有一些软件会有一些安全升级，因此通过这个工具定期给他们升级。
             5、服务器OS中一些基础软件包的修改定制。比如邮件服务定制，ftp文件服务器定制等等。
             6、一些客户定制版Bug的修复，比如Systemd管理，X server显示在arm上的一些问题等等。

【参与项目】
4、参与公司项目例如政企、军工、银行金融、电网，科研单位。具体有某省委、市委政府、军工有某造船厂、特种飞机、北斗卫星；金融有人民银行、建设银行，科研所有信工所，商密网，合肥轨交，电网有南方电网，国家电网等等。

 1、熟悉大数据生态环境及各个组件的原理，Hadoop、Spark、Kafka、Hive，Hbase，Zookeeper。
 2、熟悉ETL过程以及数据采集工具Flume/迁移工具sqoop，并实际部署过1个大型的分布式大数据集群及2个小规模集群，3年大数据经验。
 3、熟悉scala，熟练掌握scala中的高阶函数及Lambda函数式编程、akka分布式并发模型，Scala和Spark的RDD算子，?有实际的Scala大数据编程经验。
 4、非常熟悉Linux下的开发，熟练掌握shell、python，scala等脚本语言及 C/C++面向对象编程，熟悉java，5年Linux下开发经验，可以自制简易Linux发行版。
 5、对Linux整个生态系统有深刻认识，熟悉Linux下的服务器产品及架设，如LAMP，高可用HA，负载均衡Ngnix，熟练掌握Mysql，熟悉TCP/IP网络等服务器调优，4年服务器产品经验，对大型及复杂集群有一定架设及运维能力。
 6、熟练使用libvirt相关工具、熟悉容器docker，kvm及xen的虚拟化，做过华为云平台及云桌面项目，熟悉虚拟化的系统调优，2年云计算虚拟化相关经验。
 7、公司开发的社区版UbuntuKylin是与Ubuntu官方授权的发行版，经常会逛各种开源社区，跟邮件列表，并修改相应代码及功能模块满足公司定制需求，英文文档无障碍理解。

【国产化ARM平台】
ARM 3中授权，架构授权，你可以修改指令集，对整个架构进行改造。飞腾就是这一级授权。
             内核授权，将arm核心用到自己设计的芯片中，可以扩展，但不能改arm核心。
             使用授权，用已经封装好的arm芯片。



【银河超算集群云计算kvm性能评估及调优】	2018.07-至今 
项目描述： 	评估飞腾arm64整机+麒麟linux操作系统的性能：如CPU，内存，磁盘IO，网络，重点测试虚拟化性能，包括kvm以及xen的虚拟化性能对比，组建4个应用场景：
应用服务器：后端虚拟机搭建postgresql数据库服务+前端虚拟机搭建glassfish中间件,评估虚拟机应用服务能力。
web服务器：后端构建nfs服务器+前端构建apache服务器，评估虚拟机web服务性能。
邮件服务器：postfix + dovecot构建邮件服务器，评估虚拟机邮件服务能力。
批处理服务器：使用批处理工具评估虚拟机整型计算能力。 
项目职责： 	负责整个测试的规划以及性能对比，性能调优以及总结等工作。
完成飞腾arm64机器&华为机器的性能对比分析，并找出飞腾arm64机器+银河麒麟操作系统的性能弱项，并分析原因以及调优。调优项：CPU numa策略，THP透明大页，以及网络，IO等内核参数。 


【某市公安局大数据Hadoop+Zookeeper+HBase+Hive+Spark集群】 	2018.01-2018.06 
项目描述： 	搭建Hadoop分布式环境一共16个节点：其中1个NameNode和1个Secondary NameNode以及14个DataNode，数据3副本。
整个环境包括：HDFS分布式文件系统，MapReduce的Yarn架构进行配置。Zookeeper协调服务，Hbase列簇数据库，Hive数据仓库工具，Spark计算引擎（具体内容涉密）。
项目职责： 完成客户现场的Hadoop+Zookeeper+HBase+Hive+Spark集群的搭建：包括多节点搭建，HDFS，Yarn等各个组件的配置，以及Hadoop集群环境的性能调优。把之前Mysql中的数据通过Hive导入到Hbase中，对数据进行查询和索引。


【人民银行征信查询系统高可用mysql方案】	2017.01-2017.06 
项目描述： 	使用开源的高可用软件pacemaker+corosync组建双机热备系统来管理客户应用程序，使客户服务具备宕机故障等无缝切换的高可用性。
整个方案分为4个部分: drbd数据镜像系统、mysql数据库、客户应用程序、高可用软件。
1. 底层存储使用drbd数据镜像系统，并在drbd上构建ext4文件系统。
2. mysql数据库建立在drbd数据镜像系统上。
3. 上层有客户应用程序与数据库连接。
4. 高可用软件控制drbd,文件系统，mysql数据库,应用程序的切换，当主节点宕机时，将所有服务切换到备用节点上，保证服务连续性。
项目职责： 	完成技术方案：对客户需求进行分析，设计集群脑裂后的解决方案，并进行整体方案设计，可行性分析。软件选型，以及备用方案评审。编写部署及指导手册等文档。 


【合肥轨交集团华为云平台+麒麟存储产品部署】    2017/1-2017/12
项目描述：
在华为云平台FusionComputer+华为云桌面FussionAccess上适配麒麟操作系统，底层存储使用ceph方案。整个系统包含：FusionComputer华为云平台环境：计算节点代理CNA搭建，虚拟资源管理VRM搭建，另外搭建AD活动目录作为域管理服务器。
FussionAccess华为云桌面环境。底层使用麒麟存储。云桌面适配麒麟操作系统。
责任描述：
负责华为云平台上部署底层存储(iscsi多路径存储服务)，并在华为云桌面上适配麒麟操作系统。与华为云平台及云桌面工程师联调开发，解决适配过程中的不兼容等一系列问题，并最终完成麒麟操作系统在客户现场上线华为云桌面。

【信工所zabbix+postgresql硬件数据监控系统】	2016.06-2017.01 
项目描述： 	使用开源的zabbix+postgresql+php+httpd定制银河麒麟温度监控软件，对客户机房内的arm64飞腾平台所有整机进行监控，监控内容为整机CPU温度/风扇/电压等硬件信息。监控信息存入postgresql数据库中，当整机出现异常，例如CPU温度过高等，发送报警信息。 
项目职责： 	1. 完成技术方案：在arm64飞腾平台上完成监控方案的设计与部署，完成CPU传感器温度等数据获取方式的开发任务，以及监控模板及监控页面的配置。
2. 文档编写：编写监控系统部署手册，指导技服人员完成监控系统部署并完成项目的验收工作。


【华为企业网络&数据中心产线数据仓库】	2013.01-2015.12 
项目描述： 	开发工具&环境：C++、MySql、Hadoop、HIVE、Sqoop。
项目主要目的：设计统一的平台兼容各个产品的测试程序，将所有测试数据汇总，建立数据预警平台。整体架构分为Web前端、测试、数据存储，数据预警四部分。
I、Web端具体实现如下功能：收集测试人员输入的信息（如被测整机的条码、型号、需加载的主控软件版本等），提交表单并连接Mysql数据库写入相关数据；
II、测试部分：与被测整机交互，通过Socket给整机下发测试命令，实现整机的自动测试；
III：数据库部分：测试平台获取的数据存放到Mysql中。
IV：数据预警部分：将3大产品线10多个产品的测试数据汇总，并通过大数据平台分析数据，当某批次产品的某个测试子项有大量失败时，提供预警信息。 
项目职责： 	1、负责测试端开发，参与部分web前端开发（包含页面布局、动画效果、数据库操作等）。
2、参与Mysql数据库相关开发以及调优并对所有Mysql历史测试数据(PB级别)进行汇总加载到数据仓库中。
3、参与Hadoop离线计算，使用HIVE编写MR程序，计算历史数据为输出报表供产线参考。



【华为光模块产线海量发货大数据预警系统】 	2013.11-2015.12
项目描述： 	开发工具&环境：C/C++、HDFS、Yarn、Spark、Hive、Flume、Sqoop
系统分2部分：光模块测试平台，数据预警平台。
I、光模块测试项目：1）测试项目使用C/C++开发，包括光模块加密、基本信息查询、发送光功率、光接收功率、灵敏度prbs误码、Los测试、告警、激光器关断测试。
II、数据预警平台：底层文件系统使用HDFS，资源调度使用Yarn平台，计算框架使用Spark，并使用Hive做编程提取结果，将提取的结果使用sqoop导入Mysql中，通过web页面将信息展示日报月报年报，并筛选出批次问题产品，对研发人员做预警，第一时间了解相关信息。 
项目职责： 	1、主导测试平台软件的开发，包括整体架构设计、功能模块细化，以及外部仪表通信接口等。
2、参与预警平台部分工作：负责预警平台的数据采集，清洗以及加载到HDFS中，负责部分Hive编程以及调优工作，负责将计算结果迁移至Mysql中。
3、完成10GE(SFP+)光模块全自动化测试系统并顺利通过验收。涵盖绝大部分光器件厂家的光模块：Finisar、Avago、Sumitomo、JDSU、NeoPhotonics、Oclaro、Opnext、Oplink、InnoLight
等。年发货量将近千万级别的光模块做生产测试2道工序，十几个测试项目做数据预警，顺利保研发人员第一时间了解并解决生产批次问题。 
