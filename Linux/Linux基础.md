-------------------------------------------------------------------------------------------------------------------
【进程间的通信方式】

【同步、异步、阻塞、非阻塞】√
我们写一个程序，他的执行和调用过程要分为用户空间和内核空间。
阻塞指的就是用户空间发出的一个操作，要等待内核空间返回结果才执行下一步操作，内核没有返回用户空间就一直阻塞着。
非阻塞的方式就是用户空间发出的一个操作，内核立即给出一个状态值，用户空间不用等待内核空间的IO操作完成，就可以执行下一步动作。

同步异步说的是用户空间与内核空间的调用方式。
同步就是用户空间主动发起IO请求，内核空间接收请求。
异步是内核空间主动发起请求，用户空间接收。
-------------------------------------------------------------------------------------------------------------------
【bio，nio，aio】√
bio是阻塞同步io，nio是非阻塞同步io，也就是多路复用io。

网络编程中，bio一个连接对应一个线程，
IO多路复用模型的基本原理就是select/epoll系统调用，单个线程不断的轮询select/epoll系统调用所负责的成百上千的socket连接，
当某个或者某些socket网络连接有数据到达了，就返回这些可以读写的连接。
系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。
-------------------------------------------------------------------------------------------------------------------
【epoll与select区别】
select轮询效率低，主要表现在select轮询while循环里面accept监听到有客户端连接，会放到socket监听列表里，然后全表遍历一次socket监听列表，并处理有数据到达的socket。
因为每次都要遍历，所以select有限制最多监听socket1024.
epoll就没有这个限制。epoll不仅维护了socket监听列表，还维护了一个socket就绪列表。这样一旦有socket收到数据，直接将socket
写入到就绪列表中，不需要遍历监听列表了。
https://www.cnblogs.com/shijianchuzhenzhi/p/12346318.html
https://www.jianshu.com/p/dfd940e7fca2
-------------------------------------------------------------------------------------------------------------------
【如何制作linux发行版】
1、做一些准备工作，比如选择选择合适的linux宿主机。准备基础工具集，比如gcc，make汇编等工具链源码包。然后linux系统需要的最小软件包集合minimal，bash，网络管理工具等等，还有选好内核。
2、构建都是在宿主机上进行的，创建独立的分区和文件系统，通过宿主机编译gcc，make汇编等工具链。
3、使用chroot，创建根目录下的文件夹，准备好内核，并根据之前构建的工具集合把minimal中的包都编译一遍，放入指定的目录，比如很多编译好的工具需要放到bin目录，或者sbin目录。
4、接下来做配置工作，包括网络配置、时钟设置，本地化设置，/etc下面的很多配置，systemd配置。
5、最后做启动的配置，/etc/fstab挂载点，grub2启动引导。
6、基本的系统起来后，你可以做一些个性化的工作，比如你更关注虚拟化，可以集成相关虚拟化的软件，你喜欢桌面，可以集成桌面相关的包，比如x-server，KDE，mate，gnome

Hang机解决：首先判断是真死机还是假死机。比如服务器提供的服务不可用了，无法访问。
直接登录服务器，如果能登录，进去查看资源使用情况，比如top的cpu占用，内存使用，磁盘使用。
查看网络以及磁盘io的情况。是不是请求太多，io阻塞了。Top 查看cpu有90以上wait，很可能就是io阻塞造成的。
使用一些工具比如iostat查看io使用情况，查看是哪个进程占用较高，查看是哪些文件的读写较高，一步一步找到问题。

-------------------------------------------------------------------------------------------------------------------

【国产化ARM平台】
ARM 3中授权，架构授权，你可以修改指令集，对整个架构进行改造。飞腾就是这一级授权。
             内核授权，将arm核心用到自己设计的芯片中，可以扩展，但不能改arm核心。
             使用授权，使用已经封装好的arm芯片。

【云计算】
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
【kvm与xen区别】
1、kvm全虚拟化，xen半虚拟化
kvm是集成到内核中的一个动态模块，kvm.ko。需要硬件支持，比如intel和amd的cpu虚拟化支持。
xen的话，没有被集成到内核中，因此需要改造我们的内核，xen是可以直接运行在我们的硬件之上的。然后在xen的hypervisor之上运行我们的domain-0超级管理员。管理我们的虚拟机domain1-N。
而kvm全虚拟化，是把虚拟机完全的当成一个主机来运行的，运行在支持kvm内核的os之上。

-------------------------------------------------------------------------------------------------------------------
【qemu】
qemu是一套虚拟化解决方案，他可以虚拟出不同架构上的cpu，kvm只是内核模块，在核外的管理工具就是使用的改造后的qemu，

-------------------------------------------------------------------------------------------------------------------
【libvirt】

-------------------------------------------------------------------------------------------------------------------
【KVM-Qemu-Libvirt三者之间的关系】
在所谓的kvm技术中，应用到的其实有2个东西：qemu+kvm
kvm负责cpu虚拟化+内存虚拟化，但kvm不能模拟其他设备；
qemu是模拟IO设备（网卡，磁盘），kvm加上qemu之后就能实现真正意义上服务器虚拟化。
因为用到了上面两个东西，所以一般都称之为qemu-kvm。
libvirt则是调用kvm虚拟化技术的接口用于管理的，用libvirt管理方便，直接用qemu-kvm的接口太繁琐。

-------------------------------------------------------------------------------------------------------------------

【OpenStack】
OpenStack 控制节点，计算节点nova，网络节点neutron，存储节点swift，

-------------------------------------------------------------------------------------------------------------------
【io虚拟化】
io三种模式：全虚拟化，半虚拟化（virtio），直通穿透（硬件支持）
全虚拟化：kvm有一个io拦截模块，截取虚拟机中的io请求，然后发给qemu，由qemu负责与硬件进行交互。
半虚拟化：

【容器】  
容器 = cgroup + namespace + rootfs + 容器引擎
cgroup做资源管理，namespace做资源隔离。
一、cgroup
cgroup子系统 	作用
devices 	设备权限控制
cpuset 	        分配指定的CPU和内存节点
CPU 	        控制CPU使用率
cpuacct 	统计CPU使用情况
memory 	        限制内存的使用上限
freezer 	暂停Cgroup 中的进程
net_cls 	配合流控限制网络带宽
net_prio 	设置进程的网络流量优先级
perf_event 	允许 Perf 工具基于 Cgroup 分组做性能检测
huge_tlb 	限制 HugeTLB 的使用
在 Cgroup 出现之前，只能对一个进程做资源限制，如 ulimit 限制一个进程的打开文件上限、栈大小。而 Cgroup 可以对进程进行任意分组，如何分组由用户自定义。

二、 Namespace
Namespace 是将内核的全局资源做封装，使得每个namespace 都有一份独立的资源，因此不同的进程在各自的namespace内对同一种资源的使用互不干扰。
Namespace 	作用
IPC 	        隔离 System V IPC 和 POSIX 消息队列
Network 	隔离网络资源
Mount 	        隔离文件系统挂载点
PID 	        隔离进程ID
UTS 	        隔离主机名和域名

User 	        隔离用户和用户组
-------------------------------------------------------------------------------------------------------------------