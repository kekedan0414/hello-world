# 20200722-阿里云--高并发应用 问题：

1、zookeeper应用的场景。
2、布隆过滤器是什么？
3、redis穿透的解决方案？
4、布隆过滤器在redis中的什么问题。
5、除了布隆过滤器，还有什么方案解决redis穿透问题。
6、redis雪崩是什么？ 怎么解决？
7、突然大量请求过来，服务器承受不了，怎么解决？
8、令牌桶与漏桶原理？
9、分布式CAP是什么？
10、volatile 有什么用？ 除了同步，另一个作用是什么？
11、synchronize的几种级别？
12、raft与Paxos了解吗？
13、MQ的应用场景。
14、如何解决MQ消息丢失？
15、什么是一致性Hash？
16、HashMap中hash冲突了怎么办？还有没有其他方法?

---------------------------------------
## 1、zookeeper应用的场景。

Zookeeper是一个分布式的数据管理和服务协调框架，主要作用：数据发布/订阅、高可用心跳检测、命名服务、分布式协调/通知、集群管理、分布式锁、分布式队列。
比如做配置中心，一次配置，其余节点在zk上注册监听事件，就都可以拉取到最新的配置信息。
高可用心跳检测，从节点在zk上监听主节点是否存活，如果监听不到，从节点再选举出一个主节点。

参考：[ZooKeeper的三种典型应用场景](https://www.cnblogs.com/jian0110/p/10650396.html)

分布式锁：[三种实现分布式锁的方式](https://blog.csdn.net/wuzhiwei549/article/details/80692278)

## **2、redis穿透的解决方案？**

   布隆过滤器，不存在的数据设置一个null值，并设置一个合适的过期时间。

参考：[Redis布隆过滤器](https://www.cnblogs.com/ysocean/p/12594982.html)

## **3、布隆过滤器是什么？**

   布隆过滤器是一个byte二进制的数组 加多个hash函数。他可以告诉你某个事件一定不会发生，但是不能确定某个事件100%会发生。
   比如有3个hash函数，只要有一个hash函数在数组中得到的数据为0，则可以肯定这个Key不存在。但因为有hash冲突，3个hash得到1也不能100%确定数据存在，有误判率。

## **4、布隆过滤器在redis中如何解决穿透问题？**

   redis穿透是因为突然海量请求访问了数据库不存在的数据，导致直接穿透了redis，把数据库打崩。

## **5、除了布隆过滤器，还有什么方案解决redis穿透问题。**

   给不存在的数据设置一个null值，并设置一个合适的过期时间。

## **6、redis雪崩是什么？ 怎么解决？**

?    设置热点数据不过期。
?    如果不是热点数据的话，设置一个随机的过期时间，避免redis在空闲的时候大量请求过来，直接打到数据库。

## **7、突然大量请求过来，服务器承受不了，怎么解决？**

   服务限流，数据库因为历史原因，横向扩展是一件非常复杂的工程，所有我们一般会尽量把流量都挡在数据库之前。
   一是使用应用到数据库之间使用缓存，二是应用之间使用消息队列限流。三是服务降级，网络链路熔断，调用本地方法。

参考：https://blog.csdn.net/qq_37312838/article/details/82966209
    

## **8、令牌桶与漏桶原理？**

?    令牌桶与漏筒都是服务器限流的算法。
   漏桶算法能够强行限制数据的传输速率。
   令牌桶算法能够在限制数据的传输速率的同时还允许某种程度的突发传输。
   令牌桶的原理是以恒定的速率往桶里面放令牌token，拿到这个token的请求可以被处理掉。当桶里面空了，就拒绝服务。
   如果之前流量较低，桶里的令牌就会积累比较多，如果突然请求增多，可以快速拿到较多的令牌，有应对突发流量的能力。

参考：https://blog.csdn.net/m0_37477061/article/details/95313062?utm_source=blogxgwz4

## **9、分布式CAP是什么？**

+ C（consistency一致性）：数据在同一时刻时候一致。又可以分为强一致性，弱一致性，最终一致性。
+ A（可用性Avaliability）：节点故障，集群是否对外可用。
+ P（Partition Tolerance分区容忍性）：系统在发生错误的情况下，比如出现集群脑裂，也要求保持数据一致性和服务可用。
  一般来说，CAP只能满足其中两项。
  参考：[分布式系统中的CAP理论](https://baijiahao.baidu.com/s?id=1650890231453975345&wfr=spider&for=pc)

## **10、volatile 有什么用？ 除了同步，另一个作用是什么？**

volatile两个作用：
一个是并发编程的同步，也就是内存可见性，所有线程都能看到共享内存的最新状态。
原理：工作线程每次读取变量前，先把主内存的值刷过来。工作线程写变量之后，立即同步到主内存去。
另一个作用是：防止指令重排。指令重排可以提高效率，但会引入问题，比如常见的就是懒汉式的单例初始化时的并发问题。在竞争条件下可能会获得未完全初始化的单例。因为创建单例对象并不是原子操作，而是三个操作，一是分配内存空间，二是初始化对象。三是instance指向这个内存。但由于指令重排，这三个步骤打乱。还没有初始化的对象，instance就指向了它。这个时候另一个线程来获取instance，内存空间的对象还没初始化完。
volitale原理：给volitale修饰的变量写操作的时候，编译的时候会多出一条lock前缀指令，lock指令有两个作用：
       1是会立即将线程所在cpu的cache中的这个值写回主内存。
       2是其他cpu处理线程的缓存值无效，其他线程在读这个变量时，会先去拉取主内存的值，这样就保持了一致性。
使用volitale的好处是不需要像synchronize那样进行cpu上下文切换和线程调度。
volitale修饰变量。synchronize修饰变量，类，方法，代码块。

参考：作用：https://www.cnblogs.com/monkeysayhi/p/7654460.html
      原理：https://www.cnblogs.com/awkflf11/p/9218414.html

## **11、synchronize的级别？**

java中每个对象的头部都有锁信息，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。每个对象一开始都是无锁的，随着线程间争夺锁，越激烈，锁的级别越高，并且锁只能升级不能降级。

+ **偏向锁**（Biased  Locking），顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。 

+ **轻量锁**（自旋锁CAS），当前线程发现锁被占用，它会while循环一直检测锁是否释放。
  应用场景，一般用在轻量级的并发上，竞争不激烈，等待线程只需要自旋一下就可以获取到锁，避免了线程阻塞挂起等额外开销。
  优点：减少阻塞，但是while循环会加重CPU占用率。

+ **重量锁**：当自旋锁空循环一定次数还得不到锁（默认10次），就表示竞争比较激烈了，这个时候锁膨胀为重量锁，重量锁就是mutex互斥锁。互斥锁在使用中，会阻塞当前进程，而阻塞唤醒操作涉及到操作系统用户态和内核态的切换，比较费时。

https://www.cnblogs.com/wewill/p/8058292.html
如何理解锁的是对象，而不是代码：https://blog.csdn.net/weixin_34038293/article/details/92050128 

## **12、raft与Paxos了解吗？**

?	raft是分布式一致性的一个算法，主要解决分布式节点下的数据一致性问题，节点加入退出问题，脑裂问题。
?	raft有选举机制，在几个节点当中多数票选举出一个节点当Leader，其他的为follower。客户端的数据提交都会先经过leader，leader再把数据分发到follower
?	进行数据同步。
?	具体细节的话是通过日志复制来完成的。当有数据写入的时候，Leader会写日志，日志是uncommitted状态的。然后leader会把日志发给follower节点。
?        当多数节点成功写入数据时。Leader的日志状态就更新为committed状态了。

	脑裂问题，集群如果网络出了问题，那么分成两个子集群，比如5个节点，分为了3个节点的集群ABC，和2个节点集群DE，那么3个节点占多数，因此他们
	选出的leader是有效的。而D和E2个节点集群是无效的，他们接收到的写入数据请求也将是uncommitted，在网络恢复的时候DE节点会回滚并加入ABC集群，
	    保持数据一致性。

## **13、MQ的应用场景。**

?    1、抵御流量洪峰。海量的请求直接打到服务器可能导致应用服务直接奔溃，请求先进MQ保存，MQ根据服务器的最大处理能力给他消费，保证服务器的可用性。
?    2、应用服务之间的解耦。好处就是就算一个系统挂了，也只是消息积压在MQ里面没人进行消费而已，不会对其他的系统产生影响。
?    3、发布订阅模式，服务之间的异步调用，提升响应效率。比如A的某个数据，要提供非BCD，那么A需要调用BCD，如果是串行的同步的就会比较慢。
?       中间添加MQ，BCD都可以一起取数据并消费，提高了效率。

参考：https://www.cnblogs.com/jack1995/p/10908789.html

## **14、如何解决MQ消息丢失？**

 1、生产者生产消息给MQ，可能因为网络问题发生消息丢失。一般MQ接收到消息后会返回一个成功确认。如果未收到确认，就重试发送。
 2、MQ保存消息时，默认优先保存在内存中，并返回确认值给生产者。一旦MQ挂了，消息就丢失了，可以设置保存在磁盘后再发送确认值。
 3、也可以设置主从节点，把消息同步到从节点上，再返回确认值给生产者。性能会下降，生产中需要综合考虑
 4、消费者消费消息的时候，也可能发生网络问题，这时候MQ没有收到消费者的确认信息，会保留消息给消费者重试拉取。 
另一种情况就是收到消息并发送了确认，还没来得及处理就消费者挂了，消息丢失，而MQ也因为收到确认消息出列了。
解决方案：在消费者处理完这条消息后再发送确认给MQ。

参考：https://cloud.tencent.com/developer/article/1605159
      https://www.cnblogs.com/jack1995/p/10908809.html

## **15、什么是一致性Hash**

?       一致性hash解决分布式的负载均衡问题。
?       假设现在集群有3个节点，有9个请求。如果需要均衡负载的每个节点上的话，可以取模运算，除以三取余数。147,258,369分别在3个节点上。
这样看起来没什么问题，但是一旦有节点加入退出，如果还是取模运算的话，原来的全部数据需要重新分配，这样对现有的业务产生很大影响。比如除以2取余数，除以4取余数。
?      一致性hash的话，就是0到2的32次方个数形成一个环，然后对三个节点的ip进行一个hash，这三个节点就会落到一个环上分成3份。然后对这9个请求进行hash，也会落到环上，顺时针离哪个节点最近就由
哪个节点处理。他的好处就是，当有新节点加入或者退出的时候，能最小限度的影响现有系统的数据分布。比如节点1挂了，节点1的数据会给节点2处理。节点4进来了，hash落到了0和1直间，那么部分节点1的数据就交给了
节点4来处理。
?       如果只对这几个节点hash进行，可能会导致数据倾斜的问题，比如3个节点hash后在这个环上离得很近，就必然有一个节点要处理大量的数据，两个节点没事做。这时候可以引入虚拟节点来解决这个问题，
节点越多，分布越均衡。比如3个节点虚拟到300个节点，100个节点属于A节点，100个属于B，100个属于C。
?       实际解决的问题：数据均衡分片，海量请求的负载均衡.
?       均匀一致性hash：虚拟节点虽然可以改善数据倾斜，但做不到绝对的均匀。如果知道大概有多少个客户端，可以用客户端总数除以节点数，让hash在环上均匀。
参考：https://www.jianshu.com/p/e968c081f5637
?          https://www.cnblogs.com/xialihua1023/p/10304932.html
扩展：数据抖动：redis集群某个节点挂了，缓存数据丢失，用户请求直接打到数据库。
?          Hash槽：redis中集群使用hash槽解决数据负载均衡问题。redis总共有16438个槽位，如果你集群有3个节点，那就一人分5000多个槽位。然后有新数据过来，会对key计算一个hash值再取16438的模，计算出槽位号，存入数据。
?         Hash槽与一致性Hash区别：一致性Hash无法解决redis数据抖动问题。redis中Hash槽有主从节点（主节点写数据，从节点同步数据），主节点挂了，从节点选举出新的master，就相当于这部分缓存还在，不会丢失。
 hash槽参考：https://baijiahao.baidu.com/s?id=1667846581124648589&wfr=spider&for=pc
?                     https://www.jianshu.com/p/4163916a2a8a

## **16、HashMap中hash冲突了怎么办？还有没有其他方法？**

?     Java中是用的数组+链表的形式

## 17、有没有用过设计模式，熟悉什么设计模式，工厂解决什么问题？

?     Java中是用的数组+链表的形式





# 20200618相互保2interview，

## 1、HashMap线程不安全，为什么线程不安全，如何修改代码线程安全。

?          解：HashMap线程不安全的后果主要有造成死循环、数据丢失、数据覆盖。jdk1.7线程不安全主要由扩容函数引起的。jdk1.8由put函数并发的时候引起数据覆盖。如果两个线程同时插入，插入同一个bucket中的链表。

## 2、HashMap，equal和hashcode。

## 3、volitale：

比synchronize轻量级的同步机制，多线程编程里的可见性，volitale修饰的词主要不会写到线程CPU缓存中，而是直接写入内存。一个线程修改了某个值，另一个线程立即可见，而非volitale变量则在线程中读写时，变量会被拷贝到CPU缓存中。

原理就是加上了lock指令，告诉编译器禁止优化。以主内存的值为主，cpu自己cache里的值无效。

## 4、pv uv，日志按天分log文件，日志格式为【ip，url，客户端类型】，linux用什么命令来统计pv，uv

方法1：cat xx | sort | uniq |wc  或者awk '!x[$0]++' filename

## 5、AOP：

## 6、说一下shuffle：

## 7、Hbase在什么场景下使用

## 8、Hive数据倾斜

数据倾斜是进行大数据计算时常见的问题。主要分为map端倾斜和reduce端倾斜，map端倾斜主要是因为输入文件大小不均匀导致，reduce端主要是partition不均匀导致。                  

# 20201216菜鸟网络1interview

## 1、线程资源隔离，如何防止单个线程OOM



## 2、equals和hashcode为什么都要重写



### 3、minor GC触发的条件，minorgc会有什么样的影响？

# 20201216菜鸟网络2interview

1、介绍一下近期的项目。

2、你在里面主要负责什么。

3、为什么你们项目使用神经网络，而不是其他的算法？

4、你们产品解决的原有系统的什么问题？

5、一句话介绍你们的产品的价值。

6、你们项目遇到的最大的问题是什么? 如何解决它？



P7最难过的关：项目关，

1、项目的亮点在哪里，痛点在哪里？

2、架构的特点是什么？为什么采用这样的方式来设计，有没有其他更好的解决方案？

3、如果现在的流量扩充10倍百倍，你该做什么样的处理？

4、你对项目上的技术贡献在哪里？业务上有没有认真思考过？

5、对于整个行业有没有认真思考过？如果给你一个单独项目，你如何下手？

# 20201216菜鸟网络3interview

1、项目中遇到的最大挑战

2、你们多线程资源隔离如何实现

3、你没做过分布式相关的内容

4、为什么选用springcloud，而不是dubbo或者其他框架？

5、你搞底层，为什么会突然选择java？

6、为什么不选型。

7、我们在上海，你目前在长沙，愿意过来吗？