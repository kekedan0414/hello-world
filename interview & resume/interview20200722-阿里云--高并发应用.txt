问题：
1、zookeeper应用的场景。
2、布隆过滤器是什么？
3、redis穿透的解决方案？
4、布隆过滤器在redis中的什么问题。
5、除了布隆过滤器，还有什么方案解决redis穿透问题。
6、redis雪崩是什么？ 怎么解决？
7、突然大量请求过来，服务器承受不了，怎么解决？
8、令牌桶与漏桶原理？
9、分布式CAP是什么？
10、volatile 有什么用？ 除了同步，另一个作用是什么？
11、synchronize的几种级别？
12、raft与Paxos了解吗？
13、MQ的应用场景。
14、如何解决MQ消息丢失？
15、什么是一致性Hash？
16、HashMap中hash冲突了怎么办？还有没有其他方法?



---------------------------------------
1、zookeeper应用的场景。
Zookeeper是一个分布式的数据管理和服务协调框架，主要作用：数据发布/订阅、高可用心跳检测、命名服务、分布式协调/通知、集群管理、分布式锁、分布式队列。
比如做配置中心，一次配置，其余节点在zk上注册监听事件，就都可以拉取到最新的配置信息。
高可用心跳检测，从节点在zk上监听主节点是否存活，如果监听不到，从节点再选举出一个主节点。

参考：https://www.cnblogs.com/jian0110/p/10650396.html
分布式锁：https://blog.csdn.net/wuzhiwei549/article/details/80692278
----------------------------------------
3、redis穿透的解决方案？
   布隆过滤器

参考：https://baijiahao.baidu.com/s?id=1660009541007805174&wfr=spider&for=pc
----------------------------------------
2、布隆过滤器是什么？
   布隆过滤器是一个byte二进制的数组。然后有几个hash函数。他可以告诉你某个事件一定不会发生，但是不能确定某个事件100%会发生。
   比如有3个hash函数，只要有一个hash函数在数组中得到的数据为0，则可以肯定这个Key不存在。但因为有hash冲突，3个hash得到1也不能100%确定数据存在，有误判率。
----------------------------------------
4、布隆过滤器在redis中如何解决穿透问题？
   redis穿透是因为突然海量请求访问了数据库不存在的数据，导致直接绕过了redis，把数据库打崩。
   
----------------------------------------
5、除了布隆过滤器，还有什么方案解决redis穿透问题。
   给不存在的数据设置一个null值，并设置一个合适的过期时间。
----------------------------------------
6、redis雪崩是什么？ 怎么解决？
    设置热点数据不过期。
    如果不是热点数据的话，设置一个随机的过期时间，避免redis在空闲的时候大量请求过来，直接打到数据库。
----------------------------------------
7、突然大量请求过来，服务器承受不了，怎么解决？
----------------------------------------
   服务限流，数据库因为历史原因，横向扩展是一件非常复杂的工程，所有我们一般会尽量把流量都挡在数据库之前。
   一是使用应用到数据库之间使用缓存，二是应用之间使用消息队列限流。三是服务降级，网络链路熔断，调用本地方法。

参考：https://blog.csdn.net/qq_37312838/article/details/82966209
----------------------------------------   
8、令牌桶与漏桶原理？
    令牌桶与漏筒都是服务器限流的算法。
   漏桶算法能够强行限制数据的传输速率。
   令牌桶算法能够在限制数据的传输速率的同时还允许某种程度的突发传输。
   令牌桶的原理是以恒定的速率往桶里面放令牌token，拿到这个token的请求可以被处理掉。当桶里面空了，就拒绝服务。
   如果之前流量较低，桶里的令牌就会积累比较多，如果突然请求增多，可以快速拿到较多的令牌，有应对突发流量的能力。

参考：https://blog.csdn.net/m0_37477061/article/details/95313062?utm_source=blogxgwz4
----------------------------------------
9、分布式CAP是什么？
    C（consistency一致性）：数据在同一时刻时候一致。又可以分为强一致性，弱一致性，最终一致性。
    A（可用性Avaliability）：节点故障，集群是否对外可用。
    P（Partition Tolerance分区容忍性）：系统在发生错误的情况下，比如出现集群脑裂，也要求保持数据一致性和服务可用。
一般来说，CAP只能满足其中两项。
参考：https://baijiahao.baidu.com/s?id=1650890231453975345&wfr=spider&for=pc
----------------------------------------
10、volatile 有什么用？ 除了同步，另一个作用是什么？
      volatile两个作用，一个是并发编程的同步，也就是内存可见性，所有线程都能看到共享内存的最新状态。
     原理：工作线程每次读取变量前，先把主内存的值刷过来。
               工作线程写变量之后，立即同步到主内存去。

     另一个作用是：防止指令重排。指令重排可以提高效率，但会引入问题，比如常见的就是懒汉式的单例初始化时的并发问题。在竞争条件下可能会获得未完全初始化的单例。
                            因为创建单例对象并不是原子操作，而是三个操作，一是分配内存空间，二是初始化对象。三是instance指向这个内存。但由于指令重排，这三个步骤打乱。还没有初始化的对象，instance就指向了它。
                            这个时候另一个线程来获取instance，内存空间的对象还没初始化完。
volitale原理：给volitale修饰的变量写操作的时候，编译的时候会多出一条lock前缀指令，lock指令有两个作用：
       1是会立即将线程所在cpu的cache中的这个值写回主内存。
       2是其他cpu处理线程的缓存值无效，其他线程在读这个变量时，会先去拉取主内存的值，这样就保持了一致性。
使用volitale的好处是不需要像synchronize那样进行cpu上下文切换和线程调度。
volitale修饰变量。synchronize修饰变量，类，方法，代码块。

参考：作用：https://www.cnblogs.com/monkeysayhi/p/7654460.html
      原理：https://www.cnblogs.com/awkflf11/p/9218414.html
----------------------------------------
11、synchronize的级别？
java中每个对象的头部都有锁信息，锁有四种级别，按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。每个对象一开始都是无锁的，随着线程间争夺锁，越激烈，锁的级别越高，并且锁只能升级不能降级。

轻量锁（自旋锁CAS），当前线程发现锁被占用，它会while循环一直检测锁是否释放。
应用场景，一般用在轻量级的并发上，竞争不激烈，等待线程只需要自旋一下就可以获取到锁，避免了线程阻塞挂起等额外开销。
优点：减少阻塞，但是while循环会加重CPU占用率。

重量锁：当自旋锁空循环一定次数还得不到锁（默认10次），就表示竞争比较激烈了，这个时候锁膨胀为重量锁，重量锁就是mutex互斥锁。互斥锁在使用中，会阻塞当前进程，而阻塞唤醒操作涉及到操作系统用户态和内核态的切换，比较费时。

https://www.cnblogs.com/wewill/p/8058292.html
如何理解锁的是对象，而不是代码：https://blog.csdn.net/weixin_34038293/article/details/92050128 
----------------------------------------
12、raft与Paxos了解吗？
----------------------------------------
13、MQ的应用场景。
    1、抵御流量洪峰。海量的请求直接打到服务器可能导致应用服务直接奔溃，请求先进MQ保存，MQ根据服务器的最大处理能力给他消费，保证服务器的可用性。
    2、应用服务之间的解耦。好处就是就算一个系统挂了，也只是消息积压在MQ里面没人进行消费而已，不会对其他的系统产生影响。
    3、发布订阅模式，服务之间的异步调用，提升响应效率。比如A的某个数据，要提供非BCD，那么A需要调用BCD，如果是串行的同步的就会比较慢。
       中间添加MQ，BCD都可以一起取数据并消费，提高了效率。

参考：https://www.cnblogs.com/jack1995/p/10908789.html
----------------------------------------
14、如何解决MQ消息丢失？
 1、生产者生产消息给MQ，可能因为网络问题发生消息丢失。一般MQ接收到消息后会返回一个成功确认。如果未收到确认，就重试发送。
 2、MQ保存消息时，默认优先保存在内存中，并返回确认值给生产者。一旦MQ挂了，消息就丢失了，可以设置保存在磁盘后再发送确认值。
    也可以设置主从节点，把消息同步到从节点上，再返回确认值给生产者。性能会下降，生产中需要综合考虑
 4、消费者消费消息的时候，也可能发生网络问题，这时候MQ没有收到消费者的确认信息，会保留消息给消费者重试拉取。 
    另一种情况就是收到消息并发送了确认，还没来得及处理就消费者挂了，消息丢失，而MQ也因为收到确认消息出列了。
    解决方案：在消费者处理完这条消息后再发送确认给MQ。

参考：https://cloud.tencent.com/developer/article/1605159
      https://www.cnblogs.com/jack1995/p/10908809.html
----------------------------------------
15、什么是一致性Hash
       一致性hash解决分布式的负载均衡问题。
       假设现在集群有3个节点，有9个请求。如果需要均衡负载的每个节点上的话，可以取模运算，除以三取余数。147,258,369分别在3个节点上。
这样看起来没什么问题，但是一旦有节点加入退出，如果还是取模运算的话，原来的全部数据需要重新分配，这样对现有的业务产生很大影响。比如除以2取余数，除以4取余数。
      一致性hash的话，就是0到2的32次方个数形成一个环，然后对三个节点的ip进行一个hash，这三个节点就会落到一个环上分成3份。然后对这9个请求进行hash，也会落到环上，顺时针离哪个节点最近就由
哪个节点处理。他的好处就是，当有新节点加入或者退出的时候，能最小限度的影响现有系统的数据分布。比如节点1挂了，节点1的数据会给节点2处理。节点4进来了，hash落到了0和1直间，那么部分节点1的数据就交给了
节点4来处理。
       如果只对这几个节点hash进行，可能会导致数据倾斜的问题，比如3个节点hash后在这个环上离得很近，就必然有一个节点要处理大量的数据，两个节点没事做。这时候可以引入虚拟节点来解决这个问题，
节点越多，分布越均衡。比如3个节点虚拟到300个节点，100个节点属于A节点，100个属于B，100个属于C。
       实际解决的问题：数据均衡分片，海量请求的负载均衡.
       均匀一致性hash：虚拟节点虽然可以改善数据倾斜，但做不到绝对的均匀。如果知道大概有多少个客户端，可以用客户端总数除以节点数，让hash在环上均匀。
参考：https://www.jianshu.com/p/e968c081f5637
          https://www.cnblogs.com/xialihua1023/p/10304932.html
扩展：数据抖动：redis集群某个节点挂了，缓存数据丢失，用户请求直接打到数据库。
          Hash槽：redis中集群使用hash槽解决数据负载均衡问题。redis总共有16438个槽位，如果你集群有3个节点，那就一人分5000多个槽位。然后有新数据过来，会对key计算一个hash值再取16438的模，计算出槽位号，存入数据。
         Hash槽与一致性Hash区别：一致性Hash无法解决redis数据抖动问题。redis中Hash槽有主从节点（主节点写数据，从节点同步数据），主节点挂了，从节点选举出新的master，就相当于这部分缓存还在，不会丢失。
 hash槽参考：https://baijiahao.baidu.com/s?id=1667846581124648589&wfr=spider&for=pc
                     https://www.jianshu.com/p/4163916a2a8a
----------------------------------------
16、HashMap中hash冲突了怎么办？还有没有其他方法？
     Java中是用的数组+链表的形式