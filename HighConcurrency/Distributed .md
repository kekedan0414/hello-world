### CAP定理

C：数据一致性 Consistent 
A：高可用性 Available
P：分区容错性Partition Tolerance

CAP无法同时满足。
一般来说分布式系统首先要保证P分区容错性
因为不保证它，设计出来的系统将是非常糟糕的。
比如两个节点A和B做主备高可用。某一时刻心跳断了，这个时候A，B都会以为对方死掉，然后接管系统，争抢资源，这就是我们说的脑裂现象。
一旦网络恢复，比如是数据系统，那么两边的数据不一致，那你要修复这个集群，只能丢弃一边的数据了。

A就是可用性，我们通常说的高可用4个9,5个9，就是要保证尽肯能多的时候集群可用。就算某个节点宕机了，但对客户来说不感知不影响。

C就是数据一致性。集群里面通常在某个节点写入了数据后，需要把数据同步到其他节点上。

分区容错是必须保证的，在这个前提下，一致性和可用性是不可兼得的。

如果我们要保证一致性，那么我们就要加锁，保证在数据同步完成后其他节点才可用。
那么锁定期间，其他节点是不可用的。
如果要保证可用性，那么就不能锁，那一致性不成立。



**【分布式系统理论之Quorum机制】**  https://www.cnblogs.com/hapjin/p/5626889.html 

CAP极端情况就是，为了保持一致性，写的时候要写所以节点，读的时候读任意一个节点就可以了。
写操作是比较脆弱的，因为有一个节点失败了，那这次写就不成功。而读的话，就算只存活一个节点，也是能读成功的。

那么Quorum理论就是在读和写的节点数量之间取一个折中值。
一般来说，让大多数节点写入，我们就认为写入成功了，返回给前台成功。而其他数据未同步的节点可以在后台继续同步，前台不感知。
但是这样的话，读就不能只读一个节点了，因为可能读到没有更新的值。所以一般写节点+读节点要大于所有节点. 比如有5个节点，那么写节点大多数Majority是3
那么写入3个节点就算成功了。读节点也应是3，这样读出来的值，至少有1个一定能读到新值。3+3=6>5.

**【Raft机制】** 
https://www.cnblogs.com/developing/articles/11129289.html

**【Raft与Paxos区别】**
https://zhuanlan.zhihu.com/p/163271175



### 分布式锁

分布式锁的三种实现方式：

**一， 基于数据库实现分布式锁**

1. 悲观锁

利用select … where … for update 排他锁

注意: 其他附加功能与实现一基本一致，这里需要注意的是“where name=lock ”，name字段必须要走索引，否则会锁表。有些情况下，比如表不大，mysql优化器会不走这个索引，导致锁表问题。

2. 乐观锁

所谓乐观锁与前边最大区别在于基于CAS思想，是不具有互斥性，不会产生锁等待而消耗资源，操作过程中认为不存在并发冲突，只有update version失败后才能觉察到。我们的抢购、秒杀就是用了这种实现以防止超卖。

通过增加递增的版本号字段实现乐观锁

**二， 基于缓存（Redis等）实现分布式锁（AP）**

1. 使用命令介绍：

（1）SETNX

SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。

（2）expire

expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。

（3）delete

delete key：删除key

在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。

2. 实现思想：

（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。

（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。

（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

**三， 基于Zookeeper实现分布式锁（CP）**

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

> （1）创建一个目录mylock；
>  （2）线程A想获取锁就在mylock目录下创建临时顺序节点；
>  （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
>  （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
>  （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。

[分布式锁各个方案存在的一些问题](https://blog.csdn.net/qq_32924343/article/details/79814133)