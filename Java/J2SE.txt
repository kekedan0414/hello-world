【HashMap】
hashmap相当于数组和链表的一个结合方案。
数组插入和删除数据涉及移动数据，但它空间占用少。
链表新增删除数据很方便，但空间占用多。
数组和链表的平均复杂度都为o（n）
hashmap主干使用数组，通过key和映射关系直接找到数组的位置，时间复杂度为0(1)
但是映射关系可能会导致不同的key找到同一个位置，这就是hash冲突，为了解决这个问题，引入了链表，如果遇到冲突，
就以链表形式加在它位置的后面。
-------------------------------------------------------------------------------------------------------------------
【序列化与反序列化】
网络中传输是以二进制流的形式传输的，序列化就是把java对象转换成字节序，方便在网络中传输。
反序列化就是把收到的字节序转换为java对象。
-------------------------------------------------------------------------------------------------------------------
【RPC】
RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从节点与节点直接请求服务，就像是在本地调用接口服务一样。
RPC 是一种技术思想，并不是一种规范，实现它的框架比如dubbo，springcloud，netty
在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。比如springcloud是http。
tcp协议的rpc更能减少网络开销，实现更大的吞吐量和并发数。但开发难度较大。
http协议虽然网络开销更大，但是处于上层，进行二次开发非常方便。
-------------------------------------------------------------------------------------------------------------------
【Netty】
Netty是一款基于NIO开发的网络通信框架，对比于BIO，他的并发性能得到了很大提高。
说白了就是有一个selector轮询器实现多路复用 也叫事件驱动。底层用的操作系统的select(windows)和epoll(linux)轮询
-------------------------------------------------------------------------------------------------------------------
【epoll与select区别】
select轮询效率低，主要表现在select轮询到有socket数据时，还需要遍历一次socket列表来确定具体那一个socket收到了数据。
因为每次都要遍历，所以select有限制最多监听socket1024.
epoll就没有这个限制。epoll不仅维护了socket监听列表，还维护了一个socket就绪列表。这样一旦有socket收到数据，直接将socket
写入到就绪列表中，不需要遍历监听列表了。
https://www.cnblogs.com/shijianchuzhenzhi/p/12346318.html
https://www.jianshu.com/p/dfd940e7fca2
-------------------------------------------------------------------------------------------------------------------
【事件驱动模型】
通常，我们设计一个事件处理模型的程序有两种思路

    轮询方式

线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。

    事件驱动方式

发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。
事件驱动方式也被称为消息通知方式，其实是设计模式中观察者模式的思路。
-------------------------------------------------------------------------------------------------------------------
【线程池参数】
核心线程数
最大并发线程数
普通线程的空闲超时时间。
缓存队列，超过常驻的线程数的线程会进入到缓存队列，队列满了就会创建新的线程直到max最大线程数。
拒绝策略，队列满了之后，线程池到了max，那么新的任务是否丢弃还是等待。
-------------------------------------------------------------------------------------------------------------------
【1】post与get的区别
post更安全，把数据装到request body中，但耗时更久。
get不安全，url中直接包含了用户等信息，但效率更高，与服务端只交互一次。而post需要来回交互两次，第一次发送post头，然后第二次才发送内容。

【2】cookie与session的区别
cookie保存在客户端，session是服务端的概念。
cookie相当于服务端给客户端的一个通行证，然后客户端保存在自己的浏览器中，每次访问服务器时，会连同cookie一起提交给服务器。
因为http是无状态协议，因此一次连接的数据传输完成后，连接就断开。下次再连接的时候，服务器无法判断你是哪个用户。
因此服务器就需要一种机制来保存用户的信息，这就是session。第一次创建session时，就会在cookie里记录一个session id，发给客户端，
以后客户端每次发送请求的时候就会把sid发给服务器，服务器就能找到对应的session。
session第二个主要作用是，服务器一般把Session放在内存中，做session缓存，减少用户与数据库的频繁交互，例如电商购物车。 
-------------------------------------------------------------------------------------------------------------------
【3】转发与重定向
重定向：浏览器行为，浏览器发送两次请求，得到两次响应，response.sendRedirect
转发：服务器行为，发出一次请求，得到一次回应，地址栏不会变化。request.getRequestDispatcher
-------------------------------------------------------------------------------------------------------------------
【方法区与永久代与元数据空间MetaSpace】
方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。
在java1.7开始移除老年代，1.8彻底移除了老年代，取而代之的是MetaSpace。主要区别是MetaSpace放在本地内存，就不会出现永久代OOM内存溢出问题。

方法区存放什么东西：类信息，class文件，static变量与方法，final常量
-------------------------------------------------------------------------------------------------------------------
【设计模式】
spring IOC，控制反转：使用依赖注入
http://www.mamicode.com/info-detail-2691212.html
工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。

代理设计模式 : Spring AOP 功能的实现。

单例设计模式 : Spring 中的 Bean 默认都是单例的。

模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

装饰器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。

适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

JDBC 桥接模式。
-------------------------------------------------------------------------------------------------------------------
【IOC AOP】
IoC（反向控制），降低了业务逻辑中各个类的相互依赖。
以前需要自己new一个类，现在通过ioc spring帮我们创建和管理，我们直接使用就行了。如果后续代码升级需要改动，只需要改配置文件，降低耦合，提高重用性。
假如类A因为需要功能F而调用类B，在通常的情况下类A需要引用类B，因而类A就依赖于类B了，也就是说当类B不存在的时候类A就无法使用了。
使用了IoC，类A调用的仅仅是实现了功能F的接口的某个类，这个类可能是类B，也可能是另一个类C，由spring的配置文件来决定。这样，类A就不再依赖于类B了，耦合度降低，重用性提高了。

-------------------------------------------------------------------------------------------------------------------
【单例模式】
单例的作用：确保一个类只有一个实例，在整个jvm中保持唯一性，唯一的一些资源，比如线程池可以用单例。优点是唯一性，并且可以省去对象反复的创建与销毁的过程，节省资源。
懒汉式：只有在调用的时候才初始化，这样比较节省资源，但是调用的时候每次都要判断是否已经创建过单例了。
饿汉式：程序一启动就创建实例。这样会比较占资源，但是调用的时候不需要判断是否创建过单例。
-------------------------------------------------------------------------------------------------------------------
【工厂模式】
工厂模式的作用：一是方便维护。如果一份代码里有很多new操作，要进行修改的时候，代码的每一个地方都要修改。而把new操作封装在工厂里，就只要改一个地方了。
                二是符合低耦合的一个编程思想，比如有两份代码A和B，B想调用A的类，就需要new一个A，这样就会耦合在一起。但是如果使用工厂的话，对调用工厂并传参就可以得到具体的对象。
-------------------------------------------------------------------------------------------------------------------
【代理模式】
比如我不想或者不能直接调用某个类，就给他封装一层代理，我直接调用这个代理类来实现响应的功能。好处是他是一个中介，屏蔽了委托类的细节。
另外如果想增加点新功能，但不想直接修改委托类，可以在代理类上实现。
-------------------------------------------------------------------------------------------------------------------
【前后端分离】
前后端不分离的情况就是，客户端发一个请求，服务端准备好完整的页面和数据发给客户端。每次页面和数据都会发过来，传输的内容很多。
前后端分离的情况就是服务端只提供数据，一般的做法就是前端使用ajax，后端提供restful的接口，数据以json格式传输。
-------------------------------------------------------------------------------------------------------------------
【动静分离】
所谓的动静分离就是指图片，css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理
好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。 
-------------------------------------------------------------------------------------------------------------------
【Springboot】
Springboot省去了SpringMVC繁琐的配置，并且内置了tomcat，相当于一个简化开发的开发环境。
-------------------------------------------------------------------------------------------------------------------
【SpringMVC】