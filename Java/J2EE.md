### 设计模式

spring IOC，控制反转：使用依赖注入
http://www.mamicode.com/info-detail-2691212.html

https://www.zhihu.com/question/23277575/answer/169698662

工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。

代理设计模式 : Spring AOP 功能的实现。

单例设计模式 : Spring 中的 Bean 默认都是单例的。

模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

装饰器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。

适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

JDBC 桥接模式。

### IOC AOP

IoC（反向控制），降低了业务逻辑中各个类的相互依赖。
以前需要自己new一个类，现在通过ioc spring帮我们创建和管理，我们直接使用就行了。如果后续代码升级需要改动，只需要改配置文件，降低耦合，提高重用性。
假如类A因为需要功能F而调用类B，在通常的情况下类A需要引用类B，因而类A就依赖于类B了，也就是说当类B不存在的时候类A就无法使用了。
使用了IoC，类A调用的仅仅是实现了功能F的接口的某个类，这个类可能是类B，也可能是另一个类C，由spring的配置文件来决定。这样，类A就不再依赖于类B了，耦合度降低，重用性提高了。

### 单例模式

单例的作用：确保一个类只有一个实例，在整个jvm中保持唯一性，唯一的一些资源，比如线程池可以用单例。优点是唯一性，并且可以省去对象反复的创建与销毁的过程，节省资源。
懒汉式：只有在调用的时候才初始化，这样比较节省资源，但是调用的时候每次都要判断是否已经创建过单例了。
饿汉式：程序一启动就创建实例。这样会比较占资源，但是调用的时候不需要判断是否创建过单例。

### 工厂模式

工厂模式的作用：一是方便维护。如果一份代码里有很多new操作，要进行修改的时候，代码的每一个地方都要修改。而把new操作封装在工厂里，就只要改一个地方了。
二是符合低耦合的一个编程思想，比如有两份代码A和B，B想调用A的类，就需要new一个A，这样就会耦合在一起。但是如果使用工厂的话，对调用工厂并传参就可以得到具体的对象。

### 代理模式

比如我不想或者不能直接调用某个类，就给他封装一层代理，我直接调用这个代理类来实现响应的功能。好处是他是一个中介，屏蔽了委托类的细节。
另外如果想增加点新功能，但不想直接修改委托类，可以在代理类上实现。

### 序列化与反序列化

网络中传输是以二进制流的形式传输的，序列化就是把java对象转换成字节序，方便在网络中传输。
反序列化就是把收到的字节序转换为java对象。

### post与get的区别

post更安全，把数据装到request body中，但耗时更久。
get不安全，url中直接包含了用户等信息，但效率更高，与服务端只交互一次。而post需要来回交互两次，第一次发送post头，然后第二次才发送内容。

### cookie与session的区别

cookie保存在客户端，session是服务端的概念。
cookie相当于服务端给客户端的一个通行证，然后客户端保存在自己的浏览器中，每次访问服务器时，会连同cookie一起提交给服务器。
因为http是无状态协议，因此一次连接的数据传输完成后，连接就断开。下次再连接的时候，服务器无法判断你是哪个用户。
因此服务器就需要一种机制来保存用户的信息，这就是session。第一次创建session时，就会在cookie里记录一个session id，发给客户端，
以后客户端每次发送请求的时候就会把sid发给服务器，服务器就能找到对应的session。
session第二个主要作用是，服务器一般把Session放在内存中，做session缓存，减少用户与数据库的频繁交互，例如电商购物车。 

什么是无状态协议：浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。

[SSO](https://www.cnblogs.com/zh94/p/8352943.html)

### 转发与重定向

重定向：浏览器行为，浏览器发送两次请求，得到两次响应，response.sendRedirect
转发：服务器行为，发出一次请求，得到一次回应，地址栏不会变化。request.getRequestDispatcher

### 前后端分离

前后端不分离的情况就是，客户端发一个请求，服务端准备好完整的页面和数据发给客户端。每次页面和数据都会发过来，传输的内容很多。
前后端分离的情况就是服务端只提供数据，一般的做法就是前端使用ajax，后端提供restful的接口，数据以json格式传输。

### 动静分离

所谓的动静分离就是指图片，css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理
好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。 

### Springboot

Springboot省去了SpringMVC繁琐的配置，并且内置了tomcat，相当于一个简化开发的开发环境。

### SpringMVC

### RPC

RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从节点与节点直接请求服务，就像是在本地调用接口服务一样。
RPC 是一种技术思想，并不是一种规范，实现它的框架比如dubbo，springcloud，netty
在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。比如springcloud是http。
tcp协议的rpc更能减少网络开销，实现更大的吞吐量和并发数。但开发难度较大。
http协议虽然网络开销更大，但是处于上层，进行二次开发非常方便。

### Netty

Netty是一款基于NIO开发的网络通信框架，对比于BIO，他的并发性能得到了很大提高。
说白了就是有一个selector轮询器实现多路复用 也叫事件驱动。底层用的操作系统的select(windows)和epoll(linux)轮询

### epoll与select区别

select轮询效率低，主要表现在select轮询到有socket数据时，还需要遍历一次socket列表来确定具体那一个socket收到了数据。
因为每次都要遍历，所以select有限制最多监听socket1024.
epoll就没有这个限制。epoll不仅维护了socket监听列表，还维护了一个socket就绪列表。这样一旦有socket收到数据，直接将socket
写入到就绪列表中，不需要遍历监听列表了。
https://www.cnblogs.com/shijianchuzhenzhi/p/12346318.html
https://www.jianshu.com/p/dfd940e7fca2

### 事件驱动模型

通常，我们设计一个事件处理模型的程序有两种思路

    轮询方式

线程不断轮询访问相关事件发生源有没有发生事件，有发生事件就调用事件处理逻辑。

    事件驱动方式

发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。
事件驱动方式也被称为消息通知方式，其实是设计模式中观察者模式的思路。



### 云原生技术

**云原生是一类技术的统称，通过云原生技术，我们可以构建出更易于弹性扩展的应用程序。**

云原生到底包含了哪些具体的技术呢？它包含了当前业界的一些热门的技术，**比如容器、微服务、服务网格、DevOps等。**

云原生的作用：**对于应用开发团队而言**，原来云原生技术可以提升应用开发的效率，提升应用交付的质量。比如通过容器，技术开发团队可以更容易地获取开发所需要的环境与资源，开发出来的应用可以被运维团队更容易地部署和管理。通过DevOps的最佳实践，应用交付的速度和质量可以被有效的提升。

**对于业务方来说**，云原生的好处是所提交的需求，可以更快地被响应和实现。因为云原生技术可以有效地缩短应用交付的周期，让需求更快地变成代码，代码更快地变成线上的应用，最终为用户服务，实现价值。

[什么是云原生](https://www.jianshu.com/p/afaf09d8d742)

**云原生 = 微服务 + DevOps + 持续交付 + 容器化**

DevOps工具有docker，K8s

有了 DevOps（Develop开发 + Operations运维） ，团队可以定期发布代码、自动化部署、并将持续集成 / 持续交付作为发布过程的一部分。

[高清大图](http://www.jamesbowman.me/post/cdlandscape/ContinuousDeliveryToolLandscape-fullsize.jpeg)